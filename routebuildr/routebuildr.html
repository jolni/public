<!DOCTYPE html>
<html>
<head>
  <title>Route buildr</title>
  <style>
    canvas {
      display: block;
      margin: 0 auto;
	  border: none;
    }
	body {
		background-color: moccasin;
	}
  </style>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
  <table>
    <tr>
      <td colspan="3"><input type="text" id="imageUrl" placeholder="Image URL"  size="55"></td>
    </tr>
    <tr>
      <td><input type="text" id="routeName" placeholder="Name" size="5"></td>
      <td><input type="text" id="routeGrade" placeholder="Grade" size="5"></td>
      <td>Encoded link <a id="encodedURL">[link]</a></td>
    </tr>

  </table>
 
  <h3>
  <span style="color: blue">O</span>Hand/foot 
  <span style="color: red">O</span>Start/foot
  <span style="color: #8B8000">O</span>Foot only 
  <span style="color: green">O</span>Finish
  </h3>

  <canvas id="canvas" width="800" height="500"></canvas>
  <script>
    // Create an array of circle colors
    const circleColors = ["blue", "#8B8000","green", "red", "black"];
    // Create a variable to track the current circle color index
    let currentCircleColorIndex = 0;
    // Create an array to store the circles
    const circles = [];
	// scaling image vs canvas - for converting coordinates
	var gloScalingFactor;
    // Create a new image object
    const image = new Image();

	const canvas = document.querySelector("#canvas");
	const imageUrlInput = document.querySelector("#imageUrl");	
	const encodedUrlField = document.querySelector("#encodedURL");
	const routeName = document.querySelector("#routeName");
	const routeGrade = document.querySelector("#routeGrade");
	var imageRenderHeight; //scaled height, fitting canvas
	var imageRenderWidth;  //scaled width, fitting canvas 

	// ******************************** event listeners ***************************************************
    // Load the image from the URL input element
    imageUrlInput.addEventListener("change", () => {
		circles.splice(0, circles.length);
      	image.src = imageUrlInput.value;
    });

    routeGrade.addEventListener("change", () => {
      updateBookmark();
    });
    routeGrade.addEventListener("change", () => {
      updateBookmark();
    });


	// ******************************** init from optional URL parameters ***************************************************
	const urlSearchParams = new URLSearchParams(window.location.search);

	// Check if the query parameters are present
	if (urlSearchParams.has('imageUrl') && urlSearchParams.has('circles')) {
		circles.splice(0, circles.length);
	  // Deserialize the query parameters
	  const bookmark = {
		imageUrl: urlSearchParams.get('imageUrl'),
		circleList: urlSearchParams.get('circles').split(';').map((circle) => {
		  const [x, y, colorIndex] = circle.split(',');
		  return { x: parseInt(x), y: parseInt(y), colorIndex: parseInt(colorIndex) };
		}),
		name: urlSearchParams.get('name'),
		grade: urlSearchParams.get('grade'),
	  };
	  
	  const canvasContext = canvas.getContext("2d");

	  imageUrlInput.value = bookmark.imageUrl;
	  image.src = bookmark.imageUrl;
	  routeName.value = bookmark.name;
	  routeGrade.value = bookmark.grade;

	  bookmark.circleList.forEach((circleData) => {
		console.log(circleData);
        // Create a new circle
        const circle = {
          x: circleData.x,
          y: circleData.y,
          radius: 15,
          color: circleColors[circleData.colorIndex],
          stroke: true,
          colorIndex: circleData.colorIndex,
        };

        // Add the circle to the circles array
        circles.push(circle);

        // Draw the circle on the canvas
        //canvasContext.strokeStyle = circle.color;
		//canvasContext.lineWidth = 2.5;
        //canvasContext.beginPath();
        //canvasContext.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI, false);
        //canvasContext.stroke();	 
	  });
	  updateBookmark();
	}

	// ******************************** event listeners - Once the image has loaded, draw it on the canvas***************************************************

    image.onload = () => {
		const canvasContext = canvas.getContext("2d");
		canvasContext.clearRect(0, 0, canvas.width, canvas.height);

		// Get the width and height of the canvas
		const canvasWidth = canvas.width;
		const canvasHeight = canvas.height;
		// Get the width and height of the image
		imageRenderWidth = image.width;
		imageRenderHeight = image.height;

		// Calculate the scale factor
		const scaleFactor = Math.min(canvasWidth / imageRenderWidth, canvasHeight / imageRenderHeight);
		//gloScalingFactor = scaleFactor;
		gloScalingFactor = 1; //dont need, instead of scale canvas, scale drawing
		// Scale the canvas to the size of the image
		//canvasContext.scale(scaleFactor, scaleFactor);	 
		//canvasContext.drawImage(image, 0, 0);  

		// Change the resizing logic
		if (imageRenderWidth > imageRenderHeight) {
			if (imageRenderWidth > canvasWidth) {
				imageRenderHeight = imageRenderHeight * (canvasWidth / imageRenderWidth);
				imageRenderWidth = canvasWidth;
			}
		} else {
			if (imageRenderHeight > canvasHeight) {
				imageRenderWidth = imageRenderWidth * (canvasHeight / imageRenderHeight);
				imageRenderHeight = canvasHeight;
			}
		}

		canvasContext.drawImage(image, 0, 0, imageRenderWidth, imageRenderHeight);  

		// Redraw all of the circles in the circles array if there are any
		circles.forEach((circle) => {
			canvasContext.strokeStyle = circle.color;
			canvasContext.lineWidth = 2.5;
			canvasContext.beginPath();
			canvasContext.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI, false);
			canvasContext.stroke();
		});



    };

	function updateBookmark() {
		// Get the image URL, name, and grade from the fields
		const imageUrl = imageUrlInput.value;
		const name = routeName.value;
		const grade = routeGrade.value;

	  	//create bookmark of current data
		const bookmark = {
			imageUrl,
			name,
			grade,
			circles: circles.map((circle) => {
				return `${circle.x},${circle.y},${circle.colorIndex}`;
			}).join(';'),
			name,
			grade,
		};
		// Encode the bookmark object to URL-encoded string
		const encodedBookmark = new URLSearchParams(bookmark).toString();
		// Set the bookmark field value to the encoded bookmark
		history.pushState({}, '', window.location.pathname + '?' + encodedBookmark);
		encodedUrlField.href = window.location.pathname + '?' + encodedBookmark;
	}




    // Get the canvas context
    const canvasContext = canvas.getContext("2d");

    // Add an event listener to the canvas
    canvas.addEventListener("click", (event) => {
      // Get the mouse coordinates relative to the canvas
      const mouseX = event.offsetX / gloScalingFactor;
      const mouseY = event.offsetY / gloScalingFactor;

      // Check if the user clicked on an existing circle
      const nearestCircle = circles.find((circle) => {
        const distance = Math.sqrt((circle.x - mouseX) ** 2 + (circle.y - mouseY) ** 2);
        return distance <= circle.radius;
      });

      // If the user clicked on an existing circle, modify it
      if (nearestCircle) {
        // Increment the circle color index
        nearestCircle.colorIndex = (nearestCircle.colorIndex+1) % (circleColors.length);

        // Update the circle color
        nearestCircle.color = circleColors[nearestCircle.colorIndex];

        // If the circle color index is at the end of the color list, remove the circle from the canvas
        if (nearestCircle.colorIndex === circleColors.length-1) {
          // Remove the circle from the circles array
          circles.splice(circles.indexOf(nearestCircle), 1);

          // Clear the canvas
          canvasContext.clearRect(0, 0, canvas.width, canvas.height);
		  canvasContext.drawImage(image, 0, 0, imageRenderWidth, imageRenderHeight);   

          // Redraw all of the circles in the circles array
          circles.forEach((circle) => {
            canvasContext.strokeStyle = circle.color;
			canvasContext.lineWidth = 2.5;
            canvasContext.beginPath();
            canvasContext.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI, false);
            canvasContext.stroke();
          });
        } else {
          // Draw the circle on the canvas
          canvasContext.strokeStyle = nearestCircle.color;
		  canvasContext.lineWidth = 2.5;
          canvasContext.beginPath();
          canvasContext.arc(nearestCircle.x, nearestCircle.y, nearestCircle.radius, 0, 2 * Math.PI, false);
          canvasContext.stroke();
        }
      } else {
        // The user clicked on a blank space
        // Create a new circle
        const circle = {
          x: mouseX,
          y: mouseY,
          radius: 15,
          color: circleColors[currentCircleColorIndex],
          stroke: true,
          colorIndex: currentCircleColorIndex,
        };

        // Add the circle to the circles array
        circles.push(circle);

        // Draw the circle on the canvas
        canvasContext.strokeStyle = circle.color;
		canvasContext.lineWidth = 2.5;
        canvasContext.beginPath();
        canvasContext.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI, false);
        canvasContext.stroke();
      }
	  
	  updateBookmark();

	  
    });
	
	
	
  </script>
</body>
</html>